# 2022年第十三届蓝桥杯C/C++ A 组省赛赛题

## 1）裁纸刀

### 题目描述

小蓝有一个裁纸刀，每次可以将一张纸沿一条直线裁成两半。

小蓝用一张纸打印出两行三列共 6 个二维码，至少使用九次裁出来，下图给出了一种裁法。

![](https://doc.shiyanlou.com/courses/uid1357404-20220715-1657872209683/wm)

在上面的例子中，小蓝的打印机没办法打印到边缘，所以边缘至少要裁 4 次。另外，小蓝每次只能裁一张纸，不能重叠或者拼起来裁。

如果小蓝要用一张纸打印出 20 行 22 列共 440 个二维码，他至少需要裁多少次？

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

### 答案

443

### 题解

一道简单的数学题
先看例子，边缘必须裁四次，然后得到两行三列共六张二维码。
横线5裁一次，竖线6 7 8 9各裁一次，加上裁边缘的四次，共九次。
也就是说，横向裁剪次数为【行数-1】次。
竖向裁剪次数为【(列数-1)*行数】次。
题目共20行22列，则次数为：4 + 19 + (21*20) = 443次。


```cpp
#include <iostream>
using namespace std;
int main()
{
  int s;
  s=440+4-1;
  cout<<s;
  return 0;
}
```

## 2）灭鼠先锋

### 题目描述

灭鼠先锋是一个老少咸宜的棋盘小游戏，由两人参与，轮流操作。

灭鼠先锋的棋盘有各种规格，本题中游戏在两行四列的棋盘上进行。游戏的规则为：两人轮流操作，每次可选择在棋盘的一个空位上放置一个棋子，或在同一行的连续两个空位上各放置一个棋子，放下棋子后使棋盘放满的一方输掉游戏。

小蓝和小乔一起玩游戏，小蓝先手，小乔后手。小蓝可以放置棋子的方法很多，通过旋转和翻转可以对应如下四种情况：

```
XOOO XXOO OXOO OXXO
OOOO OOOO OOOO OOOO
```

其中 O 表示棋盘上的一个方格为空，X 表示该方格已经放置了棋子。

请问，对于以上四种情况，如果小蓝和小乔都是按照对自己最优的策略来玩游戏，小蓝是否能获胜。如果获胜，请用 V 表示，否则用 L 表示。请将四种情况的胜负结果按顺序连接在一起提交。

### 答案

LLLV

### 题解

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 10;
int n = 2, m = 4;
int cube[N][N], backup[N][N];

bool second();

bool check()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (!cube[i][j]) return false;
    return true;
}

bool first()
{
    if (check()) return true; // 到他下了，没地方可下说明赢了

    bool res = false;
    // 任意一个
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (!cube[i][j])
            {
                cube[i][j] = 1; // 先手 

                if (!second()) res = true; // 后手输了，先手就赢了

                cube[i][j] = 0;
            }

    // 一行两个
    for (int i = 1; i < m; i++)
    {
        if (!cube[1][i] && !cube[1][i + 1])
        {
            cube[1][i] = cube[1][i + 1] = 1;
            if (!second()) res = true;
            cube[1][i] = cube[1][i + 1] = 0;
        }

        if (!cube[2][i] && !cube[2][i + 1])
        {
            cube[2][i] = cube[2][i + 1] = 1;
            if (!second()) res = true;
            cube[2][i] = cube[2][i + 1] = 0;
        }

    }

    return res;
}

bool second()
{
    return first();
}

int main(void)
{
    memcpy(cube, backup, sizeof backup);
    cube[1][1] = 1;
    cout << (!first() ? 'V' : 'L');
    // 求得是后手胜负

    memcpy(cube, backup, sizeof backup);
    cube[1][1] = 1, cube[1][2] = 1;
    cout << (!first() ? 'V' : 'L');

    memcpy(cube, backup, sizeof backup);
    cube[1][2] = 1;
    cout << (!first() ? 'V' : 'L');

    memcpy(cube, backup, sizeof backup);
    cube[1][2] = 1, cube[1][3] = 1;
    cout << (!first() ? 'V' : 'L');

    return 0;
}
```

## 3）求和

### 题目描述

给定 n 个整数 a1,a2,...,an，求它们两两相乘再相加的和，即：

```
S=a1⋅a2+a1⋅a3+⋯+a1⋅an+a2⋅a3+⋯+an−2⋅an−1+an−2⋅an+an−1⋅an
```

输入格式：

输入的第一行包含一个整数 n。

第二行包含 n 个整数 a1,a2,...,an。

输出格式：

输出一个整数 S，表示所求的和。请使用合适的数据类型进行运算。

样例输入

```
4
1 3 6 9
```

样例输出

```
117
```

评测用例规模与约定

对于 30% 的数据，1 <= n <= 1000, 1 <= ai <= 100。

对于所有评测用例，1 <= n <= 200000, 1 <= ai <= 1000。

### 题解1

```cpp
#include <iostream>
using namespace std;
typedef long long ll;
int a[200005];
int main()
{
  int n;ll sum=0,ans=0;
  scanf("%d",&n);
  for(int i=0;i<n;i++)
  {
    scanf("%d",&a[i]);
    sum+=a[i];
  }
  for(int i=0;i<n;i++)
  {
    sum-=a[i];
    ans+=a[i]*sum;
  }
  printf("%lld",ans);
  return 0;
}
```

### 题解2

```cpp

本题如果暴力肯定会超时，拆开来看很明显是前缀和
当n=4时
ans=a1*a2+a1*a3+a1*a4+a2*a3+a2*a4+a3*a4
      =a1*(a2+a3+a4)+a2*(a3+a4)+a3*a4
就是 每个数 乘以 它之后的每个数之和 的和
至于区间的数之和就是前缀和了

一维前缀和
原数组：    a0=0  a1  a2  a3  a4……an
前缀和数组：s0=0  s1  s2  s3  s4……sn           （si=a0+a1+a2+...+ai）
(下标从1开始，并且定义s0=0是为了处理边界例如[1,x],并且保证求[l,r]公式s[r]-s[l-1]统一)

如何求si
for(i=1;i<=n;i++) s[i]=s[i-1]+ai;
求任意[l,r]的和：s[r]-s[l-1]

#include <iostream>
using namespace std;
const int N=2e5+5;
typedef long long ll;
ll n,a[N],sum[N];
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=n;i++) sum[i]+=a[i]+sum[i-1];
  ll ans=0;
  for(int i=1;i<=n;i++)
  {
    ans+=a[i]*(sum[n]-sum[i]);
  }
  cout<<ans<<endl;
  return 0;
}
```

## 4）选数异或

### 题目描述

给定一个长度为 n 的数列 A1,A2,···,An 和一个非负整数 x，给定 m 次查询，每次询问能否从某个区间 [l,r]中选择两个下标不同的数使得他们的异或等于 x。

输入格式

输入的第一行包含三个整数 n,m,x。

第二行包含 n 个整数 A1,A2,···,An。

接下来 m行，每行包含两个整数 li,ri 表示询问区间 [li,ri]。

输出格式

对于每个询问，如果该区间内存在两个数的异或为 x则输出 yes，否则输出 no。

样例输入

```
4 4 1
1 2 3 4
1 4
1 2
2 3
3 3
```

样例输出

```
yes
no
yes
no
```

评测用例规模与约定

对于 20% 的评测用例，1≤n,m≤100；
对于 40% 的评测用例，1≤n,m≤1000；
对于所有评测用例，1≤n,m≤100000，0≤x<2^20，1≤li≤ri≤n，0≤Ai<220。

### 题解1

```cpp
#include <iostream>
#include <map>
#include <cmath>
using namespace std;
int main()
{
  //我们的目的是求解区间[l,r]里是否存在a,b使得a^b=x
  //如果我们选择两两检验[l,r]里的元素，看看它们是否满足a^b=x，那效率也太低了
  //于是我们选择另辟蹊径

  int n,m,x;
  cin>>n>>m>>x;
  int Rightest[100010];//Rightest[i]表示在区间[1，i]里，满足[j,i]里存在a^b=x的，最大的一个j的取值。
  
  //我们最好不要把A1,A2,A3...中的每个值用一个数组存起来，这样效率太低，到时候还得检索
  //取而代之的是，我们用一个表格LastPosition来表示某个值最后出现的（也就是最靠右的）位置
  //这里选择map，因为A的取值最高要到2的20次方，如果创建一个这么大的数组也太浪费了，大部分数组空间都是空着的。
  map<int,int> LastPosition;

  //开始输入数字A1,A2,A3...并填写表格Rightest
  for(int i=1;i<=n;i++)
  {
    int a;
    cin>>a;
    Rightest[i]=max(Rightest[i-1],LastPosition[a^x]);
    //Rightest[i-1]:既然区间[Rightest[i-1],i-1]里存在a^b=x，那[Rightest[i-1],i]是不是也有？那Rightest[i-1]起码不会在Rightest[i]左边吧？
    //如果a^b=x，那么则有a^x=b。如果表格LastPosition里有记录过a^x出现过的位置，那LastPosition[a^x]岂不就是Rightest[i]的候选之一？
    LastPosition[a]=i;//更新a值最后出现的位置
  }

  //现在我们有了表格Rightest，对于每一个区间[l,r]，只要Rightest[r]>=l，那区间里岂不是就存在a^b=x
  while(m--)
  {
    int l,r;
    cin>>l>>r;
    if(Rightest[r]>=l)cout<<"yes"<<endl;
    else cout<<"no"<<endl;
  }
  // 请在此输入您的代码
  return 0;
}
```

### 题解2

```cpp
#include<iostream>
#include<map>
using namespace std;
typedef long long ll;
const int N=1e5+5;
ll n,m,x;
int dp[N];    // a^b=x  a,b中早出现的数字位置
map<ll,int> mp;
int max(int a,int b){
  return a>b?a:b;
}
int main()
{
  ios_base::sync_with_stdio(0);
  cin.tie(0);     // 加速（很关键！）
  cin>>n>>m>>x;
  for(int i=1;i<=n;i++){
    ll data;
    cin>>data;
    dp[i]=max(dp[i-1],mp[data^x]);    //mp存放另一个数的位置
    mp[data]=i;
  }
  while(m--){
    int l,r;
    cin>>l>>r;
    if(dp[r]>=l) cout<<"yes\n";
    else cout<<"no\n";
  }
  return 0;
}
```